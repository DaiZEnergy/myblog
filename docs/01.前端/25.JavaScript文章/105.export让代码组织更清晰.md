---
title: ES6模块化：import/export让代码组织更清晰
date: 2025-12-07 19:20:00
permalink: /pages/es6-modules/
categories:
  - 前端
  - JavaScript文章
tags:
  - ES6
  - JavaScript
  - 模块化
  - import/export
author:
  name: https://github.com/DaiZEnergy
  link: https://github.com/https://github.com/DaiZEnergy
---

# ES6 模块化：import/export 让代码组织更清晰

ES6 模块化是 JavaScript 语言层面的模块系统，它提供了统一的模块导入导出语法，让代码组织更加清晰和规范。本文将详细介绍 ES6 模块化的各种用法，帮助你构建更好的项目结构。

<!-- more -->

## 模块化的发展历程

### 1. 传统方式的问题

在 ES6 之前，JavaScript 没有原生的模块系统，开发者使用各种方式来实现模块化：

```javascript
// 1. 全局变量污染
var myModule = {
  name: "myModule",
  doSomething: function () {
    console.log("doing something");
  },
};

// 2. IIFE（立即执行函数表达式）
var MyModule = (function () {
  var privateVar = "private";

  return {
    publicMethod: function () {
      console.log(privateVar);
    },
  };
})();

// 3. CommonJS（Node.js）
// module.exports = { ... };
// const module = require('./module');

// 4. AMD（RequireJS）
// define(['dependency'], function(dependency) { ... });
```

### 2. ES6 模块化的优势

- **静态分析**：编译时就能确定模块的依赖关系
- **树摇优化**：打包工具可以移除未使用的代码
- **循环依赖检测**：能够检测和处理循环依赖
- **标准化**：语言层面的标准，所有现代浏览器都支持

## 基本语法

### 1. 导出（Export）

#### 命名导出

```javascript
// math.js
export const PI = 3.14159;
export const E = 2.71828;

export function add(a, b) {
  return a + b;
}

export function multiply(a, b) {
  return a * b;
}

// 也可以先声明后导出
const subtract = (a, b) => a - b;
const divide = (a, b) => a / b;

export { subtract, divide };
```

#### 默认导出

```javascript
// calculator.js
class Calculator {
  constructor() {
    this.history = [];
  }

  add(a, b) {
    const result = a + b;
    this.history.push(`${a} + ${b} = ${result}`);
    return result;
  }

  getHistory() {
    return this.history;
  }
}

export default Calculator;
```

#### 混合导出

```javascript
// utils.js
export const VERSION = "1.0.0";

export function formatDate(date) {
  return date.toISOString().split("T")[0];
}

export default class Utils {
  static formatCurrency(amount) {
    return `$${amount.toFixed(2)}`;
  }
}
```

### 2. 导入（Import）

#### 命名导入

```javascript
// 导入单个
import { add, multiply } from "./math.js";

// 导入多个
import { add, multiply, PI, E } from "./math.js";

// 导入所有并重命名
import * as math from "./math.js";
console.log(math.add(1, 2)); // 3

// 重命名导入
import { add as addNumbers, multiply as multiplyNumbers } from "./math.js";
```

#### 默认导入

```javascript
// 导入默认导出
import Calculator from "./calculator.js";

const calc = new Calculator();
console.log(calc.add(1, 2)); // 3

// 重命名默认导入
import MyCalculator from "./calculator.js";
```

#### 混合导入

```javascript
// 同时导入默认和命名导出
import Utils, { VERSION, formatDate } from "./utils.js";

console.log(VERSION); // '1.0.0'
console.log(formatDate(new Date())); // '2024-12-19'
console.log(Utils.formatCurrency(100)); // '$100.00'
```

## 高级用法

### 1. 重新导出

```javascript
// math-advanced.js
import { add, multiply } from "./math.js";

export { add, multiply }; // 重新导出

// 重新导出并重命名
export { add as plus, multiply as times };

// 重新导出所有
export * from "./math.js";

// 重新导出默认
export { default } from "./calculator.js";
```

### 2. 动态导入

```javascript
// 静态导入（编译时确定）
import { add } from "./math.js";

// 动态导入（运行时确定）
async function loadModule() {
  const math = await import("./math.js");
  console.log(math.add(1, 2));
}

// 条件导入
if (condition) {
  const module = await import("./module.js");
  module.doSomething();
}

// 动态导入默认导出
const { default: Calculator } = await import("./calculator.js");
const calc = new Calculator();
```

### 3. 导入时执行

```javascript
// side-effect.js
console.log("模块被加载了");

// 只执行模块，不导入任何内容
import "./side-effect.js";
```

## 实际应用场景

### 1. 工具函数模块

```javascript
// utils/string.js
export function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

export function truncate(str, length) {
  return str.length > length ? str.slice(0, length) + "..." : str;
}

export function slugify(str) {
  return str
    .toLowerCase()
    .replace(/[^a-z0-9 -]/g, "")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-");
}

// utils/date.js
export function formatDate(date, format = "YYYY-MM-DD") {
  const d = new Date(date);
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");

  return format.replace("YYYY", year).replace("MM", month).replace("DD", day);
}

export function addDays(date, days) {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

// utils/index.js - 统一导出
export * from "./string.js";
export * from "./date.js";
```

### 2. API 服务模块

```javascript
// services/api.js
class ApiService {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const response = await fetch(url, {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    });

    if (!response.ok) {
      throw new Error(`HTTP错误: ${response.status}`);
    }

    return response.json();
  }

  async get(endpoint) {
    return this.request(endpoint, { method: 'GET' });
  }

  async post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data)
    });
  }
}

export default ApiService;

// services/userService.js
import ApiService from './api.js';

class UserService {
  constructor(apiService) {
    this.api = apiService;
  }

  async getUsers() {
    return this.api.get('/users');
  }

  async getUser(id) {
    return this.api.get(`/users/${id}`);
  }

  async createUser(userData) {
    return this.api.post('/users', userData);
  }
}

export default UserService;

// services/index.js
import ApiService from './api.js';
import UserService from './userService.js';

const apiService = new ApiService('https://api.example.com');
const userService = new UserService(apiService);

export { apiService, userService };
export default { apiService, userService };
```

### 3. 组件模块

```javascript
// components/Button.js
export class Button {
  constructor(text, onClick) {
    this.text = text;
    this.onClick = onClick;
    this.element = this.createElement();
  }

  createElement() {
    const button = document.createElement("button");
    button.textContent = this.text;
    button.addEventListener("click", this.onClick);
    return button;
  }

  render(container) {
    container.appendChild(this.element);
  }

  destroy() {
    this.element.remove();
  }
}

// components/Modal.js
export class Modal {
  constructor(title, content) {
    this.title = title;
    this.content = content;
    this.element = this.createElement();
  }

  createElement() {
    const modal = document.createElement("div");
    modal.className = "modal";
    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-header">
          <h2>${this.title}</h2>
          <button class="close">&times;</button>
        </div>
        <div class="modal-body">
          ${this.content}
        </div>
      </div>
    `;

    modal.querySelector(".close").addEventListener("click", () => {
      this.close();
    });

    return modal;
  }

  show() {
    document.body.appendChild(this.element);
  }

  close() {
    this.element.remove();
  }
}

// components/index.js
export { Button } from "./Button.js";
export { Modal } from "./Modal.js";
```

### 4. 配置文件模块

```javascript
// config/database.js
export const databaseConfig = {
  host: process.env.DB_HOST || "localhost",
  port: process.env.DB_PORT || 5432,
  username: process.env.DB_USERNAME || "admin",
  password: process.env.DB_PASSWORD || "password",
  database: process.env.DB_NAME || "myapp",
};

// config/api.js
export const apiConfig = {
  baseURL: process.env.API_BASE_URL || "https://api.example.com",
  timeout: parseInt(process.env.API_TIMEOUT) || 5000,
  retries: parseInt(process.env.API_RETRIES) || 3,
};

// config/index.js
export { databaseConfig } from "./database.js";
export { apiConfig } from "./api.js";

export const config = {
  database: databaseConfig,
  api: apiConfig,
  environment: process.env.NODE_ENV || "development",
};
```

## 模块打包和构建

### 1. 使用 Webpack

```javascript
// webpack.config.js
const path = require("path");

module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.resolve(__dirname, "dist"),
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: "babel-loader",
          options: {
            presets: ["@babel/preset-env"],
          },
        },
      },
    ],
  },
};
```

### 2. 使用 Vite

```javascript
// vite.config.js
import { defineConfig } from "vite";

export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        main: "./index.html",
        admin: "./admin.html",
      },
    },
  },
});
```

### 3. 使用 ESBuild

```javascript
// esbuild.config.js
import { build } from "esbuild";

build({
  entryPoints: ["src/index.js"],
  bundle: true,
  outfile: "dist/bundle.js",
  format: "esm",
  target: "es2020",
});
```

## 最佳实践

### 1. 模块组织

```
src/
├── components/
│   ├── Button/
│   │   ├── Button.js
│   │   ├── Button.css
│   │   └── index.js
│   └── index.js
├── services/
│   ├── api.js
│   ├── userService.js
│   └── index.js
├── utils/
│   ├── string.js
│   ├── date.js
│   └── index.js
├── config/
│   └── index.js
└── index.js
```

### 2. 循环依赖处理

```javascript
// 避免循环依赖
// ❌ 错误示例
// a.js
import { b } from "./b.js";
export const a = "a";

// b.js
import { a } from "./a.js"; // 循环依赖
export const b = "b";

// ✅ 正确做法
// a.js
export const a = "a";

// b.js
export const b = "b";

// c.js
import { a } from "./a.js";
import { b } from "./b.js";
export const c = a + b;
```

### 3. 性能优化

```javascript
// 懒加载大型模块
const loadHeavyModule = async () => {
  const { HeavyComponent } = await import("./HeavyComponent.js");
  return HeavyComponent;
};

// 条件加载
if (user.isAdmin) {
  const { AdminPanel } = await import("./AdminPanel.js");
  // 使用AdminPanel
}
```

### 4. 类型安全（TypeScript）

```typescript
// types/api.ts
export interface User {
  id: number;
  name: string;
  email: string;
}

export interface ApiResponse<T> {
  data: T;
  message: string;
  success: boolean;
}

// services/userService.ts
import { User, ApiResponse } from "../types/api.js";

export class UserService {
  async getUsers(): Promise<ApiResponse<User[]>> {
    // 实现
  }
}
```

## 总结

ES6 模块化为 JavaScript 带来了标准化的模块系统：

**主要优势：**

- 静态分析，编译时确定依赖
- 支持树摇优化
- 循环依赖检测
- 标准化语法

**核心概念：**

- `export`：导出模块内容
- `import`：导入模块内容
- 命名导出 vs 默认导出
- 动态导入

**最佳实践：**

- 合理组织模块结构
- 避免循环依赖
- 使用懒加载优化性能
- 结合 TypeScript 提供类型安全

掌握 ES6 模块化，能够让你的 JavaScript 项目更加清晰、可维护和高效。

> 作者：dzh  
> 链接：https://github.com/DaiZEnergy
