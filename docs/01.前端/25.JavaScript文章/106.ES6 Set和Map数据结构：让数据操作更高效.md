---
title: ES6 Set和Map数据结构：让数据操作更高效
date: 2026-02-26 20:30:00
permalink: /pages/set-map/
categories:
  - 前端
  - JavaScript文章
tags:
  - ES6
  - JavaScript
  - Set
  - Map
  - 数据结构
author:
  name: https://github.com/DaiZEnergy
  link: https://github.com/https://github.com/DaiZEnergy
---

# ES6 Set 和 Map 数据结构：让数据操作更高效

ES6 引入了 Set 和 Map 两种新的数据结构，它们为 JavaScript 提供了更强大的数据存储和操作能力。Set 用于存储唯一值，Map 用于存储键值对，它们都比传统的数组和对象在某些场景下更加高效和适用。

<!-- more -->

## Set 数据结构

Set 是一种集合数据结构，类似于数组，但成员的值都是唯一的，没有重复的值。

### 1. 基本用法

```javascript
// 创建Set
const mySet = new Set();

// 添加值
mySet.add(1);
mySet.add(2);
mySet.add(3);
mySet.add(2); // 重复值，不会添加

console.log(mySet); // Set(3) {1, 2, 3}

// 从数组创建Set
const numbers = [1, 2, 3, 2, 4, 3, 5];
const uniqueNumbers = new Set(numbers);
console.log(uniqueNumbers); // Set(5) {1, 2, 3, 4, 5}

// 从字符串创建Set
const chars = new Set("hello");
console.log(chars); // Set(4) {"h", "e", "l", "o"}
```

### 2. Set 的属性和方法

```javascript
const mySet = new Set([1, 2, 3, 4, 5]);

// 属性
console.log(mySet.size); // 5

// 方法
mySet.add(6); // 添加值
mySet.has(3); // true - 检查是否存在
mySet.delete(3); // true - 删除值
mySet.clear(); // 清空Set

// 遍历方法
mySet.forEach((value) => console.log(value));

// 迭代器
for (const value of mySet) {
  console.log(value);
}

// 转换为数组
const array = [...mySet];
const array2 = Array.from(mySet);
```

### 3. Set 的实际应用

#### 数组去重

```javascript
// 传统方法
function uniqueArray(arr) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    if (result.indexOf(arr[i]) === -1) {
      result.push(arr[i]);
    }
  }
  return result;
}

// 使用Set
function uniqueArrayWithSet(arr) {
  return [...new Set(arr)];
}

// 性能对比
const largeArray = Array.from({ length: 10000 }, () =>
  Math.floor(Math.random() * 1000)
);

console.time("传统方法");
uniqueArray(largeArray);
console.timeEnd("传统方法");

console.time("Set方法");
uniqueArrayWithSet(largeArray);
console.timeEnd("Set方法");
```

#### 集合运算

```javascript
// 并集
function union(setA, setB) {
  return new Set([...setA, ...setB]);
}

// 交集
function intersection(setA, setB) {
  return new Set([...setA].filter((x) => setB.has(x)));
}

// 差集
function difference(setA, setB) {
  return new Set([...setA].filter((x) => !setB.has(x)));
}

// 对称差集
function symmetricDifference(setA, setB) {
  return new Set([...difference(setA, setB), ...difference(setB, setA)]);
}

// 使用示例
const setA = new Set([1, 2, 3, 4]);
const setB = new Set([3, 4, 5, 6]);

console.log(union(setA, setB)); // Set(6) {1, 2, 3, 4, 5, 6}
console.log(intersection(setA, setB)); // Set(2) {3, 4}
console.log(difference(setA, setB)); // Set(2) {1, 2}
console.log(symmetricDifference(setA, setB)); // Set(4) {1, 2, 5, 6}
```

#### 权限管理

```javascript
class PermissionManager {
  constructor() {
    this.permissions = new Set();
  }

  addPermission(permission) {
    this.permissions.add(permission);
  }

  removePermission(permission) {
    this.permissions.delete(permission);
  }

  hasPermission(permission) {
    return this.permissions.has(permission);
  }

  hasAnyPermission(requiredPermissions) {
    return requiredPermissions.some((permission) =>
      this.permissions.has(permission)
    );
  }

  hasAllPermissions(requiredPermissions) {
    return requiredPermissions.every((permission) =>
      this.permissions.has(permission)
    );
  }

  getPermissions() {
    return [...this.permissions];
  }
}

// 使用示例
const user = new PermissionManager();
user.addPermission("read");
user.addPermission("write");
user.addPermission("delete");

console.log(user.hasPermission("read")); // true
console.log(user.hasAnyPermission(["read", "admin"])); // true
console.log(user.hasAllPermissions(["read", "write", "admin"])); // false
```

## Map 数据结构

Map 是一种键值对的数据结构，类似于对象，但键可以是任何类型的值。

### 1. 基本用法

```javascript
// 创建Map
const myMap = new Map();

// 添加键值对
myMap.set("name", "张三");
myMap.set("age", 25);
myMap.set(true, "布尔值作为键");
myMap.set({ id: 1 }, "对象作为键");

console.log(myMap); // Map(4) {"name" => "张三", "age" => 25, true => "布尔值作为键", {…} => "对象作为键"}

// 从数组创建Map
const entries = [
  ["name", "李四"],
  ["age", 30],
  ["city", "北京"],
];
const personMap = new Map(entries);
console.log(personMap); // Map(3) {"name" => "李四", "age" => 30, "city" => "北京"}

// 从对象创建Map
const obj = { a: 1, b: 2, c: 3 };
const mapFromObj = new Map(Object.entries(obj));
console.log(mapFromObj); // Map(3) {"a" => 1, "b" => 2, "c" => 3}
```

### 2. Map 的属性和方法

```javascript
const myMap = new Map([
  ["name", "王五"],
  ["age", 28],
  ["city", "上海"],
]);

// 属性
console.log(myMap.size); // 3

// 方法
myMap.set("email", "wangwu@example.com"); // 设置值
console.log(myMap.get("name")); // '王五' - 获取值
console.log(myMap.has("age")); // true - 检查键是否存在
myMap.delete("age"); // true - 删除键值对
myMap.clear(); // 清空Map

// 遍历方法
myMap.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});

// 迭代器
for (const [key, value] of myMap) {
  console.log(`${key}: ${value}`);
}

// 获取所有键
console.log([...myMap.keys()]); // ['name', 'age', 'city']

// 获取所有值
console.log([...myMap.values()]); // ['王五', 28, '上海']

// 获取所有键值对
console.log([...myMap.entries()]); // [['name', '王五'], ['age', 28], ['city', '上海']]
```

### 3. Map 的实际应用

#### 缓存系统

```javascript
class Cache {
  constructor(maxSize = 100) {
    this.cache = new Map();
    this.maxSize = maxSize;
  }

  get(key) {
    if (this.cache.has(key)) {
      // 将访问的项移到末尾（LRU策略）
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return null;
  }

  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // 删除最旧的项
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }

  has(key) {
    return this.cache.has(key);
  }

  delete(key) {
    return this.cache.delete(key);
  }

  clear() {
    this.cache.clear();
  }

  size() {
    return this.cache.size;
  }
}

// 使用示例
const cache = new Cache(3);
cache.set("user:1", { name: "张三", age: 25 });
cache.set("user:2", { name: "李四", age: 30 });
cache.set("user:3", { name: "王五", age: 28 });

console.log(cache.get("user:1")); // {name: '张三', age: 25}
cache.set("user:4", { name: "赵六", age: 35 }); // 会删除user:2
console.log(cache.get("user:2")); // null
```

#### 计数器

```javascript
class Counter {
  constructor() {
    this.counts = new Map();
  }

  increment(key) {
    this.counts.set(key, (this.counts.get(key) || 0) + 1);
  }

  decrement(key) {
    const current = this.counts.get(key) || 0;
    if (current > 0) {
      this.counts.set(key, current - 1);
    }
  }

  get(key) {
    return this.counts.get(key) || 0;
  }

  getTop(n = 5) {
    return [...this.counts.entries()].sort((a, b) => b[1] - a[1]).slice(0, n);
  }

  reset() {
    this.counts.clear();
  }
}

// 使用示例
const counter = new Counter();
counter.increment("apple");
counter.increment("banana");
counter.increment("apple");
counter.increment("orange");
counter.increment("banana");
counter.increment("apple");

console.log(counter.get("apple")); // 3
console.log(counter.getTop(3)); // [['apple', 3], ['banana', 2], ['orange', 1]]
```

#### 数据分组

```javascript
function groupBy(array, keyFn) {
  const groups = new Map();

  for (const item of array) {
    const key = keyFn(item);
    if (!groups.has(key)) {
      groups.set(key, []);
    }
    groups.get(key).push(item);
  }

  return groups;
}

// 使用示例
const students = [
  { name: "张三", grade: "A", subject: "数学" },
  { name: "李四", grade: "B", subject: "数学" },
  { name: "王五", grade: "A", subject: "英语" },
  { name: "赵六", grade: "C", subject: "数学" },
  { name: "钱七", grade: "B", subject: "英语" },
];

// 按成绩分组
const byGrade = groupBy(students, (student) => student.grade);
console.log(byGrade);
// Map(3) {
//   'A' => [{name: '张三', grade: 'A', subject: '数学'}, {name: '王五', grade: 'A', subject: '英语'}],
//   'B' => [{name: '李四', grade: 'B', subject: '数学'}, {name: '钱七', grade: 'B', subject: '英语'}],
//   'C' => [{name: '赵六', grade: 'C', subject: '数学'}]
// }

// 按科目分组
const bySubject = groupBy(students, (student) => student.subject);
console.log(bySubject);
```

## WeakSet 和 WeakMap

### 1. WeakSet

WeakSet 是 Set 的弱引用版本，只能存储对象，且不会阻止垃圾回收。

```javascript
const weakSet = new WeakSet();
const obj1 = { name: "obj1" };
const obj2 = { name: "obj2" };

weakSet.add(obj1);
weakSet.add(obj2);

console.log(weakSet.has(obj1)); // true

// 当obj1被垃圾回收后，WeakSet中的引用也会被自动清除
obj1 = null;
```

### 2. WeakMap

WeakMap 是 Map 的弱引用版本，键必须是对象，且不会阻止垃圾回收。

```javascript
const weakMap = new WeakMap();
const obj1 = { id: 1 };
const obj2 = { id: 2 };

weakMap.set(obj1, "value1");
weakMap.set(obj2, "value2");

console.log(weakMap.get(obj1)); // 'value1'

// 当obj1被垃圾回收后，WeakMap中的键值对也会被自动清除
obj1 = null;
```

## 性能对比

### 1. 查找性能

```javascript
const array = Array.from({ length: 10000 }, (_, i) => i);
const set = new Set(array);
const object = {};
array.forEach((item, index) => {
  object[item] = index;
});

const target = 5000;

// 数组查找
console.time("Array.indexOf");
array.indexOf(target);
console.timeEnd("Array.indexOf");

// Set查找
console.time("Set.has");
set.has(target);
console.timeEnd("Set.has");

// 对象查找
console.time("Object property");
object.hasOwnProperty(target);
console.timeEnd("Object property");
```

### 2. 插入性能

```javascript
const iterations = 10000;

// 数组插入
console.time("Array.push");
const arr = [];
for (let i = 0; i < iterations; i++) {
  arr.push(i);
}
console.timeEnd("Array.push");

// Set插入
console.time("Set.add");
const set = new Set();
for (let i = 0; i < iterations; i++) {
  set.add(i);
}
console.timeEnd("Set.add");

// Map插入
console.time("Map.set");
const map = new Map();
for (let i = 0; i < iterations; i++) {
  map.set(i, i);
}
console.timeEnd("Map.set");
```

## 最佳实践

### 1. 何时使用 Set

```javascript
// ✅ 适合使用Set的场景
const uniqueIds = new Set(); // 存储唯一ID
const visitedPages = new Set(); // 记录访问过的页面
const permissions = new Set(["read", "write", "delete"]); // 权限集合

// ❌ 不适合使用Set的场景
const userData = new Set(); // 需要存储复杂对象数据
const sortedData = new Set(); // 需要保持插入顺序
```

### 2. 何时使用 Map

```javascript
// ✅ 适合使用Map的场景
const userCache = new Map(); // 缓存用户数据
const eventHandlers = new Map(); // 存储事件处理器
const metadata = new Map(); // 存储元数据

// ❌ 不适合使用Map的场景
const simpleObject = new Map(); // 简单的键值对，对象更合适
const jsonData = new Map(); // 需要JSON序列化
```

### 3. 内存管理

```javascript
// 及时清理不需要的数据
const cache = new Map();
// ... 使用cache
cache.clear(); // 及时清理

// 使用WeakMap避免内存泄漏
const privateData = new WeakMap();
class MyClass {
  constructor() {
    privateData.set(this, {
      secret: "private data",
    });
  }

  getSecret() {
    return privateData.get(this).secret;
  }
}
```

## 总结

Set 和 Map 是 ES6 中非常重要的数据结构：

**Set 的优势：**

- 自动去重
- 高效的查找和插入
- 支持集合运算
- 适合存储唯一值

**Map 的优势：**

- 键可以是任何类型
- 保持插入顺序
- 高效的查找和插入
- 适合存储键值对

**使用建议：**

- 需要去重时使用 Set
- 需要键值对存储时使用 Map
- 考虑内存管理，适时使用 WeakSet 和 WeakMap
- 根据性能需求选择合适的数据结构

掌握 Set 和 Map 的使用，能够让你的 JavaScript 代码更加高效和优雅。

> 作者：dzh  
> 链接：https://github.com/DaiZEnergy
