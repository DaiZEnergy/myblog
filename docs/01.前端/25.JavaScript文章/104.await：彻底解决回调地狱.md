---
title: ES6 Promise和async/await：彻底解决回调地狱
date: 2025-12-07 10:30:00
sticky: 1
permalink: /pages/promise-async-await/
categories:
  - 前端
  - JavaScript文章
tags:
  - ES6
  - JavaScript
  - Promise
  - async/await
author:
  name: https://github.com/DaiZEnergy
  link: https://github.com/https://github.com/DaiZEnergy
---

# ES6 Promise 和 async/await：彻底解决回调地狱

JavaScript 的异步编程一直是开发者面临的挑战，从早期的回调函数到 Promise，再到 async/await，JavaScript 的异步处理方式在不断演进。本文将深入探讨 Promise 和 async/await 的使用方法，帮助你彻底掌握现代 JavaScript 异步编程。

<!-- more -->

## 回调地狱问题

在 Promise 出现之前，JavaScript 主要使用回调函数处理异步操作，这导致了著名的"回调地狱"问题：

```javascript
// 回调地狱示例
getData(function (a) {
  getMoreData(
    a,
    function (b) {
      getEvenMoreData(
        b,
        function (c) {
          getFinalData(
            c,
            function (d) {
              console.log("最终结果:", d);
            },
            function (error) {
              console.error("获取最终数据失败:", error);
            }
          );
        },
        function (error) {
          console.error("获取更多数据失败:", error);
        }
      );
    },
    function (error) {
      console.error("获取数据失败:", error);
    }
  );
});
```

这种嵌套结构难以阅读、维护和调试，Promise 的出现就是为了解决这个问题。

## Promise 基础

### 1. 创建 Promise

```javascript
// 基本语法
const promise = new Promise((resolve, reject) => {
  // 异步操作
  setTimeout(() => {
    const success = Math.random() > 0.5;
    if (success) {
      resolve("操作成功");
    } else {
      reject("操作失败");
    }
  }, 1000);
});

// 使用Promise
promise
  .then((result) => console.log(result))
  .catch((error) => console.error(error));
```

### 2. Promise 的三种状态

```javascript
// 1. pending（进行中）
const pendingPromise = new Promise((resolve, reject) => {
  // 状态为pending
});

// 2. fulfilled（已成功）
const fulfilledPromise = Promise.resolve("成功");

// 3. rejected（已失败）
const rejectedPromise = Promise.reject("失败");
```

### 3. 基本用法

```javascript
// 模拟API请求
function fetchUserData(userId) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (userId > 0) {
        resolve({
          id: userId,
          name: "张三",
          email: "zhangsan@example.com",
        });
      } else {
        reject(new Error("无效的用户ID"));
      }
    }, 1000);
  });
}

// 使用Promise
fetchUserData(123)
  .then((user) => {
    console.log("用户信息:", user);
    return user.name; // 返回新值
  })
  .then((name) => {
    console.log("用户名:", name);
  })
  .catch((error) => {
    console.error("获取用户信息失败:", error.message);
  });
```

## Promise 高级用法

### 1. Promise.all() - 并行执行

```javascript
// 同时执行多个异步操作
const promise1 = fetchUserData(1);
const promise2 = fetchUserData(2);
const promise3 = fetchUserData(3);

Promise.all([promise1, promise2, promise3])
  .then((users) => {
    console.log("所有用户信息:", users);
  })
  .catch((error) => {
    console.error("获取用户信息失败:", error);
  });

// 实际应用：批量获取数据
async function loadDashboardData() {
  try {
    const [users, posts, comments] = await Promise.all([
      fetch("/api/users"),
      fetch("/api/posts"),
      fetch("/api/comments"),
    ]);

    return {
      users: await users.json(),
      posts: await posts.json(),
      comments: await comments.json(),
    };
  } catch (error) {
    console.error("加载仪表板数据失败:", error);
  }
}
```

### 2. Promise.race() - 竞速执行

```javascript
// 获取最快响应的结果
function fetchWithTimeout(url, timeout = 5000) {
  const fetchPromise = fetch(url);
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error("请求超时")), timeout);
  });

  return Promise.race([fetchPromise, timeoutPromise]);
}

// 使用示例
fetchWithTimeout("/api/data", 3000)
  .then((response) => response.json())
  .then((data) => console.log("数据:", data))
  .catch((error) => console.error("请求失败:", error));
```

### 3. Promise.allSettled() - 等待所有完成

```javascript
// 等待所有Promise完成，不管成功还是失败
const promises = [
  fetch("/api/users"),
  fetch("/api/posts"),
  fetch("/api/invalid-endpoint"), // 这个会失败
];

Promise.allSettled(promises).then((results) => {
  results.forEach((result, index) => {
    if (result.status === "fulfilled") {
      console.log(`请求 ${index} 成功:`, result.value);
    } else {
      console.log(`请求 ${index} 失败:`, result.reason);
    }
  });
});
```

### 4. Promise.any() - 获取第一个成功的

```javascript
// 获取第一个成功的Promise
const promises = [
  fetch("/api/primary"),
  fetch("/api/backup1"),
  fetch("/api/backup2"),
];

Promise.any(promises)
  .then((response) => {
    console.log("获取到数据:", response);
  })
  .catch((error) => {
    console.error("所有请求都失败了:", error);
  });
```

## async/await 语法

async/await 是 Promise 的语法糖，让异步代码看起来像同步代码。

### 1. 基本用法

```javascript
// 使用async/await重写Promise示例
async function getUserData(userId) {
  try {
    const user = await fetchUserData(userId);
    console.log("用户信息:", user);
    return user.name;
  } catch (error) {
    console.error("获取用户信息失败:", error.message);
    throw error;
  }
}

// 调用async函数
getUserData(123)
  .then((name) => console.log("用户名:", name))
  .catch((error) => console.error("处理失败:", error));
```

### 2. 并行执行

```javascript
// 并行执行多个异步操作
async function loadMultipleUsers() {
  try {
    // 并行执行，不是串行
    const [user1, user2, user3] = await Promise.all([
      fetchUserData(1),
      fetchUserData(2),
      fetchUserData(3),
    ]);

    console.log("用户1:", user1);
    console.log("用户2:", user2);
    console.log("用户3:", user3);

    return [user1, user2, user3];
  } catch (error) {
    console.error("加载用户失败:", error);
  }
}
```

### 3. 错误处理

```javascript
// 多种错误处理方式
async function handleErrors() {
  try {
    const user = await fetchUserData(-1); // 这会失败
    return user;
  } catch (error) {
    if (error.message.includes("无效的用户ID")) {
      console.log("用户ID无效，使用默认用户");
      return { id: 0, name: "默认用户", email: "default@example.com" };
    } else {
      console.error("未知错误:", error);
      throw error;
    }
  }
}
```

## 实际应用场景

### 1. API 请求封装

```javascript
class ApiClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
      ...options,
    };

    try {
      const response = await fetch(url, config);

      if (!response.ok) {
        throw new Error(`HTTP错误: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("API请求失败:", error);
      throw error;
    }
  }

  async get(endpoint) {
    return this.request(endpoint, { method: "GET" });
  }

  async post(endpoint, data) {
    return this.request(endpoint, {
      method: "POST",
      body: JSON.stringify(data),
    });
  }
}

// 使用示例
const api = new ApiClient("https://api.example.com");

async function loadUserProfile(userId) {
  try {
    const user = await api.get(`/users/${userId}`);
    const posts = await api.get(`/users/${userId}/posts`);

    return {
      ...user,
      posts,
    };
  } catch (error) {
    console.error("加载用户资料失败:", error);
    return null;
  }
}
```

### 2. 文件上传

```javascript
async function uploadFile(file, onProgress) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();

    // 上传进度
    xhr.upload.addEventListener("progress", (event) => {
      if (event.lengthComputable) {
        const percentComplete = (event.loaded / event.total) * 100;
        onProgress(percentComplete);
      }
    });

    // 上传完成
    xhr.addEventListener("load", () => {
      if (xhr.status === 200) {
        resolve(JSON.parse(xhr.responseText));
      } else {
        reject(new Error(`上传失败: ${xhr.status}`));
      }
    });

    // 上传错误
    xhr.addEventListener("error", () => {
      reject(new Error("上传过程中发生错误"));
    });

    // 开始上传
    const formData = new FormData();
    formData.append("file", file);
    xhr.open("POST", "/api/upload");
    xhr.send(formData);
  });
}

// 使用示例
async function handleFileUpload(file) {
  try {
    const result = await uploadFile(file, (progress) => {
      console.log(`上传进度: ${progress.toFixed(2)}%`);
    });
    console.log("上传成功:", result);
  } catch (error) {
    console.error("上传失败:", error);
  }
}
```

### 3. 数据缓存

```javascript
class DataCache {
  constructor() {
    this.cache = new Map();
    this.pendingRequests = new Map();
  }

  async get(key, fetcher, ttl = 300000) {
    // 默认5分钟
    // 检查缓存
    if (this.cache.has(key)) {
      const { data, timestamp } = this.cache.get(key);
      if (Date.now() - timestamp < ttl) {
        return data;
      }
    }

    // 检查是否有正在进行的请求
    if (this.pendingRequests.has(key)) {
      return this.pendingRequests.get(key);
    }

    // 创建新的请求
    const promise = this.fetchAndCache(key, fetcher);
    this.pendingRequests.set(key, promise);

    try {
      const result = await promise;
      return result;
    } finally {
      this.pendingRequests.delete(key);
    }
  }

  async fetchAndCache(key, fetcher) {
    const data = await fetcher();
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
    });
    return data;
  }
}

// 使用示例
const cache = new DataCache();

async function getUserData(userId) {
  return cache.get(`user-${userId}`, async () => {
    const response = await fetch(`/api/users/${userId}`);
    return response.json();
  });
}
```

## 最佳实践

### 1. 错误处理

```javascript
// 好的错误处理
async function robustApiCall() {
  try {
    const response = await fetch("/api/data");

    if (!response.ok) {
      throw new Error(`API错误: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    if (error.name === "TypeError") {
      console.error("网络错误:", error.message);
    } else if (error.name === "SyntaxError") {
      console.error("JSON解析错误:", error.message);
    } else {
      console.error("未知错误:", error.message);
    }
    throw error;
  }
}
```

### 2. 超时处理

```javascript
// 带超时的异步函数
function withTimeout(promise, timeoutMs) {
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error("操作超时")), timeoutMs);
  });

  return Promise.race([promise, timeoutPromise]);
}

// 使用示例
async function fetchWithTimeout() {
  try {
    const data = await withTimeout(
      fetch("/api/slow-endpoint").then((r) => r.json()),
      5000
    );
    return data;
  } catch (error) {
    if (error.message === "操作超时") {
      console.error("请求超时，请稍后重试");
    } else {
      console.error("请求失败:", error);
    }
  }
}
```

### 3. 重试机制

```javascript
// 带重试的异步函数
async function withRetry(fn, maxRetries = 3, delay = 1000) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) {
        throw error;
      }

      console.log(`尝试 ${i + 1} 失败，${delay}ms后重试...`);
      await new Promise((resolve) => setTimeout(resolve, delay));
      delay *= 2; // 指数退避
    }
  }
}

// 使用示例
async function reliableApiCall() {
  return withRetry(async () => {
    const response = await fetch("/api/unreliable-endpoint");
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return response.json();
  });
}
```

## 总结

Promise 和 async/await 是现代 JavaScript 异步编程的核心：

**Promise 的优势：**

- 解决了回调地狱问题
- 提供了统一的异步处理接口
- 支持链式调用和错误传播
- 提供了多种组合方法（all、race 等）

**async/await 的优势：**

- 让异步代码看起来像同步代码
- 更直观的错误处理
- 更好的调试体验
- 更容易理解和维护

在实际开发中，建议：

1. 优先使用 async/await 语法
2. 合理使用 Promise.all 进行并行处理
3. 做好错误处理和超时控制
4. 考虑使用缓存和重试机制
5. 避免在循环中使用 await（除非需要串行执行）

掌握这些异步编程技巧，将大大提升你的 JavaScript 开发效率和代码质量。

> 作者：dzh  
> 链接：https://github.com/DaiZEnergy
